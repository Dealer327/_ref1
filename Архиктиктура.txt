                   Архитектура


=================== Общий раздел ===================

1. Вид релиза приложения

    Несколько файлов с кодом, выполняемых с помощью интерпретатора Python 3.10.


2. Структура приложения

    Модуль верхнего уровня, включающий в себя суперцикл с обработкой команд пользователя и вызовом основных функций.

    Дополнительные модули, содержащие все основные функции приложения.

    Модули стандартной библиотеки.


3. Структура хранения данных

    Два INI-файла для хранения информации об игроках (players.ini) и о сохранённых партиях (saves.ini)

    players.ini

        [player1]
        first_time = True
        stats = 1,0,1

        [player2]
        ...

    saves.ini

        # ДОБАВИТЬ: здесь и в файле дописать пример хранения данных о сделанных ходах в сжатом текстовом виде (есть в моём проекте)

        [player1,player2]
        X = player1
        turns =

        [player3,player2]
        ...

4. Работа с данными в приложении

    # Имена игроков, статистика игроков

        {'player1': {'first_time': True,
                     'stats': {'wins': 1, 'ties': 0, 'fails': 1}},

         'player2': {'first_time': False,
                     'stats': {'wins': 3, 'ties': 2, 'fails': 0}},

         ...}

    # Сохранённые незаконченные партии

         {frozenset({'player1', 'player2'}):
                   {'turns': , 'X': 'player1'},

          frozenset({'player3', 'player2'}):
                   {'turns': , 'X': 'player2'},

          ...}

    # Ходы в текущей партии

        ОТВЕТИТЬ: так всё-таки словарь или матрица?

        {frozenset({'player1', 'player2'}):
            {'X': 'player1',
             'player1': (1, 4, 5),
             'player2': (2, 3, 8)}}



================ Этапы работы приложения =============

1. Загрузка файлов настроек

2. ЕСЛИ первый запуск приложения:
        вывод раздела помощи

3. Запрос имени игрока
    а) ЕСЛИ имя среди зарегистрированных игроков:
            ИСТИНА: выбираем этого игрока как активного
            ЛОЖЬ: запускаем процесс создания нового игрока и делаем его активным

Суперцикл:

    4. Ожидание ввода пользовательских команд:

        # new_game

            5. Запрос режима игры
                а) ЕСЛИ "бот":
                        запрос уровня сложности
                б) ЕСЛИ "два человека":
                        запрос имени второго игрока

            6. Запрос символа для игры

            7. ЕСЛИ первая партия для любого из игроков:
                    включение режима обучения

            8. Партия

            9. ЕСЛИ партия закончена досрочно:
                    сохранение данных о партии

            10. Внесение изменений в статистику игрока(-ов)

        # load_game

            5. Проверка наличия сохранённых партий для текущего игрока
                а) ЕСЛИ партии есть:
                        ИСТИНА: вывести все сохранённые партии для текущего игрока
                        ЛОЖЬ: прервать процесс загрузки партии, вернуться к ожиданию ввода пользовательских команд

            6. Запрос партии для загрузки (из выведенных)

            7. Партия

            8. ЕСЛИ партия закончена досрочно:

                    ИСТИНА: сохранение данных о партии

                    ЛОЖЬ: 9. Внесение изменений в статистику игрока(-ов)

                          10. Удаление данных о доигранной сохранённой партии

11. Запись данных в конфигурационные файлы




================= Основные функции =================

read_ini() -> bool:
    """Читает конфигурационные файлы, сохраняет прочитанные данные в глобальные переменные статистики и сохранений и возвращает True если приложение запущено впервые, иначе False."""


save_ini():
    """Записывает конфигурационные файлы, из глобальных переменных статистики и сохранений."""


show_help() -> None:
    """Выводит в stdout раздел помощи."""


new_player(player_name: str) -> None:
    """Создаёт запись о новом игроке в глобальной переменной статистики."""


load() -> bool:
    """Выводит в stdout все сохранённые партии для текущего игрока, запрашивает партию для загрузки, настраивает глобальные переменные и возвращает True/False в зависимости от очерёдности хода."""


change_dimension() -> None:
    """Запрашивает у пользователя новую размерность игрового поля и пересчитывает соответствующий диапазон."""


get_player_name() -> None:
    """Запрашивает имя игрока и проверяет присутствие этого имени в глобальной переменной статистики, добавляет имя в глобальную переменную текущих игроков."""


game_mode() -> str:
    """Запрашивает режим для новой партии, добавляет имя бота либо второго игрока в глобальную переменную текущих игроков, запрашивает очерёдность ходов."""


is_first_game() -> bool:
    """Проверяет является ли данная партия первой для любого из игроков."""


print_board(board: config.Matrix, *boards: config.Matrix, right: bool = False) -> None:
    """Выводит в stdout игровое поле с ходами либо другими символами."""


human_turn():
    """Запрос координат ячейки поля для текущего хода."""


game(zero_turn=False) -> config.Score | None:
    """Обрабатывает игровой процесс."""


update_stats(score: config.Score) -> None:
    """Обновляет глобальную переменную статистики в соответствии с результатом завершённой партии."""


save_game() -> None:
    """Обновляет глобальную переменную сохранений в соответствии с текущим состоянием глобальных переменных текущих игроков и сделанных ходов."""


bot_turn() -> config.TurnCoords:
    """Возвращает координаты ячейки поля для текущего хода бота в зависимости от сложности."""


easy_mode() -> config.TurnCoords:
    """Рассчитывает координат ячейки поля для текущего хода бота для низкого уровня сложности."""


hard_mode(token_index: int) -> config.TurnCoords:
    """Рассчитывает координат ячейки поля для текущего хода для высокого уровня сложности."""


cells_row(matrix: config.Matrix, row_index: int) -> tuple:
    """Возвращает кортеж с элементами ряда матрицы по индексу ряда."""


cells_column(matrix: config.Matrix, column_index: int) -> tuple:
    """Возвращает кортеж с элементами столбца матрицы по индексу столбца."""


cells_maindiagonal(matrix: config.Matrix, row_index: int, column_index: int) -> tuple:
    """Возвращает кортеж с элементами главной диагонали матрицы по индексам ряда и столбца."""


cells_antidiagonal(matrix: config.Matrix, row_index: int, column_index: int) -> tuple:
    """Возвращает кортеж с элементами побочной диагонали матрицы по индексам ряда и столбца."""


sum_matrix(*matrices: config.Matrix) -> config.Matrix:
    """Поэлементно складывает переданные матрицы и возвращает результирующую матрицу."""


indexes_matrix_max(matrix: config.Matrix) -> config.TurnCoords:
    """Находит наибольший элемент в матрице и возвращает индексы этого элемента в виде кортежа."""


weights_tokens(board: config.Matrix, token_index: int) -> config.Matrix:
    """Конструирует и возвращает матрицу весов занятых ячеек игрового поля."""


weights_empty(tokens_weights: config.Matrix) -> config.Matrix:
    """Вычисляет и возвращает матрицу весов пустых ячеек игрового поля."""


weights_clear(empty_weights: config.Matrix) -> config.Matrix:
    """Обрабатывает матрицу принятия решения, приравнивая к нолю элементы, соответствующие занятым на поле клеткам."""


calc_strategy_matrices() -> None:
    """Вычисляет и заполняет начальные матрицы принятия решений для стратегий 'крестика' и 'нолика'."""

